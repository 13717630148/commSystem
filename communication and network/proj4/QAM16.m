% ----------------------------------------------------------------------- %
% It is the project of modulation 16QAM with the real signal.
%
% Written by Tingwu Wang, Tsinghua University, for the course project
% 29/10/2015
% ----------------------------------------------------------------------- %
clear all; close all; clc;

numSample = 2500;
N = numSample * 4;  % 250 sample points are selected
t = [0 : 1/20 : numSample - 1 / 20];  % one Sample is sent in 1 s

x = randn(1, N); x(x >= 0.5) = 1; x(x < 0.5) = -1;  % signal generated
I0(1: N / 2) = x(1: 2: N);  % the 16QAM signal is generated by them
Q0(1: N / 2) = x(2: 2: N);  

I = zeros(1, N / 4); Q = zeros(1, N / 4);
for n = 1: 2: N / 2 - 1
    I(floor(n/2)+1) = I0(n)*2 + I0(n+1);
    Q(floor(n/2)+1) = Q0(n)*2 + Q0(n+1);
end

% the signal then pass a sqrt raise cosine singal filter. The over sample 
% rate is 20, and the alpha is 0.5. Thus the original 250 points is no 
% sampled into 250 * 20 = 50 data
I_s = rcosflt(I, 1, 20, 'sqrt', 0.5); I_s = I_s(61 : end - 60);
Q_s = rcosflt(Q, 1, 20, 'sqrt', 0.5); Q_s = Q_s(61 : end - 60);

w = 2 * pi * 4;  % one sample sent in 1s, therefore 4 is the freq
QAM_Signal = I_s' .* cos(w * t) - Q_s' .* sin(w * t);  % it is the signal

% plot the I, Q signal sent. The 1/4s is the Ts, and each delta t is 1 /
% 20s
figure; subplot(2,1,1); hold on;
for n = 1: 2 * 20 : numSample * 20 - 2 * 20  % we plot 2 period
    plot(I_s(n : n + 2 * 20));
end;
hold off; title('The sent I signal');
subplot(2,1,2); hold on;
for n = 1: 40 : numSample * 20 - 40
    plot(Q_s(n : n + 40));
end
hold off; title('The sent Q signal');

% Calculate the recover result when no noise is around
I_received_noNoise = 2 * (QAM_Signal) .* cos(w*t);
Q_received_noNoise = 2 * (QAM_Signal) .* (-sin(w*t));

I_received_noNoise = rcosflt(I_received_noNoise, 1, 20, 'sqrt/Fs', 0.5);
I_received_noNoise = I_received_noNoise(61: end - 61);
Q_received_noNoise = rcosflt(Q_received_noNoise, 1, 20, 'sqrt/Fs', 0.5);
Q_received_noNoise = Q_received_noNoise(61: end - 61);

figure; subplot(2,1,1); hold on;
for n = 1: 40 : numSample * 20 - 40
    plot(I_received_noNoise(n: n + 40));
end
hold off; title('The recoverd I signal with no noise');
subplot(2,1,2); hold on;
for n = 1: 40 : numSample * 20 - 40
    plot(Q_received_noNoise(n: n + 40));
end
hold off; title('The recoverd Q signal with no noise');

% now consider the noise, 1 to 16 db is considered
MQAM_noise = awgn(QAM_Signal, 15 - 10 * log10(2), 'measured');
MQAM_ndb = zeros(16, length(QAM_Signal));
for n = 1: 16
    MQAM_ndb(n, :) = awgn(QAM_Signal, n - 10 * log10(2), 'measured');
end

figure; plot((MQAM_noise(1:100))); title('The first 100 signal')

I_decoded = zeros(16, length(MQAM_ndb(n,:)));
Q_decoded = zeros(16, length(MQAM_ndb(n,:)));
for n = 1: 16
    I_decoded(n,:) = 2*(MQAM_ndb(n,:)).*cos(w*t);
    Q_decoded(n,:) = 2*(MQAM_ndb(n,:)).*(-sin(w*t));
end
I_recovered = zeros(16, numSample * 20 + 120);
Q_recovered = zeros(16, numSample * 20 + 120);
for n = 1: 16
    I_recovered(n,:) = rcosflt(I_decoded(n,:), 1, 20, 'sqrt/Fs', 0.5);
    Q_recovered(n,:) = rcosflt(Q_decoded(n,:), 1, 20, 'sqrt/Fs', 0.5);
end
I_recovered = I_recovered(:, 61: end - 60);
Q_recovered = Q_recovered(:, 61: end - 60);

I_j = zeros(16, numSample);
Q_j = zeros(16, numSample);
for n = 1: 20: numSample * 20
    I_j(:,floor(n/20)+1) = ...
        (I_recovered(:,n)<=-2)*(-3) + ...
        ((I_recovered(:,n)>-2).*(I_recovered(:,n)<0))*(-1) + ...
        (I_recovered(:,n)>=2)*3 + ...
        ((I_recovered(:,n)<2).*(I_recovered(:,n)>=0))*1;
    Q_j(:,floor(n/20)+1) = (Q_recovered(:,n)<=-2) * ...
        (-3)+((Q_recovered(:,n)>-2).*(Q_recovered(:,n)<0))*(-1) ...
        +(Q_recovered(:,n)>=2) * 3 + ...
        ((Q_recovered(:,n)<2).*(Q_recovered(:,n)>=0))*1;
end

% recover the results
I_out = zeros(16, N/2); Q_out=zeros(16, N/2);
for n = 1: numSample
    I_out(:,(n-1)*2+1:n*2) = ...
        (I_j(:,n)==3)*[1,1] + ...
        (I_j(:,n)==1)*[1,-1]+(I_j(:,n)==-1)*[-1,1]+(I_j(:,n)==-3)*[-1,-1];
    Q_out(:,(n-1)*2+1:n*2) = ...
        (Q_j(:,n)==3)*[1,1] + ...
        (Q_j(:,n)==1)*[1,-1]+(Q_j(:,n)==-1)*[-1,1]+(Q_j(:,n)==-3)*[-1,-1];
end
Output = zeros(16,N);
Output(:, 1:2:N) = I_out;
Output(:, 2:2:N) = Q_out;

% calculate the bit error
pb = zeros(16, 1);
pb_theory = zeros(16, 1);
for k = 1:16
    pb(k) = 1 - sum(Output(k,:) == x) / N;
end
figure; subplot(2,1,1); grid on;
plot(pb); title('The simulated BER curve'); grid on;
for k = 1:16
    pb_theory(k) = 4 / 4 * (1 - 1 / 4) * qfunc(sqrt(3*4/15*10^(k / 10)));
    %pb_theory(k) = 2*(4-1)/4*qfunc(sqrt(6*2/15*k));
end
subplot(2,1,2); plot(pb_theory); grid on;
title('The theoretical BER curve');

% calculate the symbol error
k_bits = 4;  % 4 bits
ps = zeros(16, 1);
ps_theory = zeros(16, 1);
for k = 1:16
    error = 0;
    for i = 1: 1: numSample
        if all(Output(k, 1 + (i - 1) * 4 : i * 4) == x(1 + (i - 1) * 4 : i * 4))
            continue
        else
            error = error + 1;
        end
    end
    ps(k) = error / numSample;
end
figure; subplot(2,1,1); grid on;
plot(ps); title('The simulated SER curve'); grid on;
for k = 1:16
    ps_theory(k) = 1 - (1 - (4 / 4 * (1 - 1 / 4) * qfunc(sqrt(3*4/15*10^(k / 10)))) * k_bits / 2)^2;
end
subplot(2,1,2); plot(ps_theory); grid on;
title('The theoretical SER curve');
